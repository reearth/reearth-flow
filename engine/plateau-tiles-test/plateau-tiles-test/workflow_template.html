<!doctype html>
<meta charset="utf-8"/>
<title>Workflow Viewer</title>
<style>
  body{font-family:Arial;margin:0;display:flex;height:100vh}
  #panel{width:400px;padding:10px;background:#f9f9f9;overflow-y:auto}
  #resizer{width:5px;background:#ddd;cursor:col-resize;flex-shrink:0}
  #resizer:hover{background:#999}
  #edgeInfo{font-size:12px;}
  svg{flex:1}
  .meta-list{list-style:none;padding:0;margin:0 0 10px;font-size:11px}
  .node-rect{fill:#fff;stroke:#333;stroke-width:1.2}
  .node-label{font-size:12px;pointer-events:none}
  .node-label-action{font-weight:bold}
  .edgePath{stroke:#666;stroke-width:1.6;fill:none;marker-end:url(#arrow)}
  .edge-label{font-size:11px;font-weight:bold;fill:#06c;cursor:pointer}
  .edge-label:hover{fill:#f00}
  .tree-item{font-size:12px}
  .tree-toggle{cursor:pointer;color:#06c;margin-right:4px;width:12px;display:inline-block}
  .tree-key{font-weight:600}
  .tree-value{color:#666;word-break:break-all;white-space:pre-wrap}
  .tree-children{margin-left:16px;display:none}
  .tree-children.expanded{display:block}
  .filter-input{width:100%}
</style>

<div id=panel>
  <select id=graphSel style="width:100%;padding:4px"></select>
  <input type="text" class="filter-input" id="filterInput" placeholder="Filter: feature => feature.attributes.name === 'example'" value="f => " />
  <div id="edgeInfo"></div>
  <div id="featureList"></div>
</div>

<div id=resizer></div>

<svg id=svg></svg>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>

<script>
const workflowDoc = JSON.parse(`{{WORKFLOW_JSON}}`);
const edgeDataMap = JSON.parse(`{{EDGE_DATA}}`);
const graphSel = document.getElementById('graphSel');
const edgeInfo = document.getElementById('edgeInfo');
const featureList = document.getElementById('featureList');
const filterInput = document.getElementById('filterInput');
const panel = document.getElementById('panel');
const resizer = document.getElementById('resizer');
const svg = d3.select('#svg');
let currentEdgeId = null;
let currentFeatures = [];
let displayedCount = 0;
const BATCH_SIZE = 50;

let isResizing = false;
resizer.addEventListener('mousedown', (e) => {
  isResizing = true;
  e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
  if (!isResizing) return;
  const newWidth = e.clientX;
  if (newWidth > 200 && newWidth < window.innerWidth * 0.8) {
    panel.style.width = newWidth + 'px';
    updateSvgSize();
  }
});

document.addEventListener('mouseup', () => {
  isResizing = false;
});

function updateSvgSize(){
  const w = window.innerWidth - panel.offsetWidth - resizer.offsetWidth;
  svg.attr('width', w).attr('height', window.innerHeight);
}
updateSvgSize();

function loadEdgeData(edgeId){
  const edgeData = edgeDataMap[edgeId];
  if(!edgeData){
    edgeInfo.innerHTML = '<li>No data available</li>';
    featureList.innerHTML = '';
    return;
  }

  currentEdgeId = edgeId;
  currentFeatures = edgeData.features || [];

  // Apply current filter if any
  applyFilter();
}

function applyFilter(){
  const filterCode = filterInput.value.trim();
  const indexed = currentFeatures.map((f, i) => ({feature: f, originalIndex: i}));

  if(!filterCode){
    displayEdgeData(currentEdgeId, indexed);
    return;
  }

  try {
    // Eval is required to provide flexibility of any filter function but can be dangerous.
    // The generated HTML is for localhost debugging purpose only and should not be deployed publicly.
    const filterFn = filterCode.includes('=>') ? eval(`(${filterCode})`) : eval(`(f => ${filterCode})`);
    displayEdgeData(currentEdgeId, indexed.filter(item => filterFn(item.feature)));
  } catch(err) {
    console.log(`filter error: ${err.message}`);
    displayEdgeData(currentEdgeId, indexed);
  }
}

filterInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter'){
    applyFilter();
  }
});

function renderTreeValue(value, path = '', depth = 0) {
  const uniqueId = `tree-${path}-${Math.random().toString(36).substr(2, 9)}`;
  const shouldExpand = depth <= 1;

  if (value === null || value === undefined) {
    return `<span class="tree-value">null</span>`;
  }

  if (typeof value === 'object' && !Array.isArray(value)) {
    const keys = Object.keys(value);
    if (keys.length === 0) {
      return `<span class="tree-value">{}</span>`;
    }
    let html = `<div class="tree-item">
      <span class="tree-toggle" onclick="toggleTree('${uniqueId}')">${shouldExpand ? '▼' : '▶'}</span>
      <span class="tree-value">{${keys.length}}</span>
      <div class="tree-children${shouldExpand ? ' expanded' : ''}" id="${uniqueId}">`;
    for (const [k, v] of Object.entries(value)) {
      html += `<div><span class="tree-key">${k}:</span> ${renderTreeValue(v, path + '.' + k, depth + 1)}</div>`;
    }
    html += `</div></div>`;
    return html;
  }

  if (Array.isArray(value)) {
    if (value.length === 0) {
      return `<span class="tree-value">[]</span>`;
    }
    let html = `<div class="tree-item">
      <span class="tree-toggle" onclick="toggleTree('${uniqueId}')">${shouldExpand ? '▼' : '▶'}</span>
      <span class="tree-value">[${value.length}]</span>
      <div class="tree-children${shouldExpand ? ' expanded' : ''}" id="${uniqueId}">`;
    value.forEach((v, idx) => {
      html += `<div><span class="tree-key">[${idx}]:</span> ${renderTreeValue(v, path + '[' + idx + ']', depth + 1)}</div>`;
    });
    html += `</div></div>`;
    return html;
  }

  return `<span class="tree-value">${value}</span>`;
}

function toggleTree(id) {
  const element = document.getElementById(id);
  const toggle = element.previousElementSibling.previousElementSibling;
  if (element.classList.contains('expanded')) {
    element.classList.remove('expanded');
    toggle.textContent = '▶';
  } else {
    element.classList.add('expanded');
    toggle.textContent = '▼';
  }
}

let currentDisplayFeatures = [];

function displayEdgeData(edgeId, featuresWithIndices){
  currentDisplayFeatures = featuresWithIndices;
  displayedCount = 0;

  const totalCount = currentFeatures.length;
  const filteredCount = featuresWithIndices.length;
  const countText = filteredCount < totalCount ? `${filteredCount} / ${totalCount}` : `${totalCount}`;

  edgeInfo.innerHTML = `Edge ID: ${edgeId}: ${countText} features`;
  featureList.innerHTML = '';

  loadMoreFeatures();
}

function loadMoreFeatures(){
  if(!featureList) return;

  const endIndex = Math.min(displayedCount + BATCH_SIZE, currentDisplayFeatures.length);
  let html = '';

  for(let idx = displayedCount; idx < endIndex; idx++){
    const item = currentDisplayFeatures[idx];
    const originalIdx = item.originalIndex;
    const feature = item.feature;
    html += `<div class="info-section">`;
    html += renderTreeValue(feature, `feature-${originalIdx}`);
    html += `</div>`;
  }

  featureList.insertAdjacentHTML('beforeend', html);
  displayedCount = endIndex;

  // Remove old load more button if exists
  const oldBtn = document.getElementById('loadMoreBtn');
  if(oldBtn) oldBtn.remove();

  // Add load more button if there are more features
  if(displayedCount < currentDisplayFeatures.length){
    const remaining = currentDisplayFeatures.length - displayedCount;
    featureList.insertAdjacentHTML('beforeend',
      `<div class="info-section" style="text-align:center">
        <button id="loadMoreBtn" onclick="loadMoreFeatures()" style="padding:8px 16px;cursor:pointer">
          Load More (${remaining} remaining)
        </button>
      </div>`);
  }
}

function findGraphs(doc){
  if(!doc) return [];
  if(Array.isArray(doc.graphs)) return doc.graphs;
  if(doc.nodes && doc.edges) return [doc];
  return [];
}

function layoutAndRender(graph){
  svg.selectAll('*').remove();
  const container = svg.append('g');
  const zoom = d3.zoom()
    .filter(event => event.type === 'mousedown' && event.button === 1)
    .scaleExtent([0.2,3])
    .on('zoom', e => container.attr('transform', e.transform));
  svg.call(zoom);

  svg.on('wheel', function(event) {
    event.preventDefault();
    const transform = d3.zoomTransform(this);

    // Detect pinch (ctrlKey is set by browser for pinch-to-zoom gestures)
    if (event.ctrlKey) {
      // Pinch to zoom
      const scale = transform.k * Math.pow(2, -event.deltaY * 0.01);
      const clampedScale = Math.max(0.2, Math.min(3, scale));
      const point = d3.pointer(event, this);
      const newTransform = transform.translate(point[0], point[1])
        .scale(clampedScale / transform.k)
        .translate(-point[0], -point[1]);
      d3.select(this).call(zoom.transform, newTransform);
    } else {
      // Two-finger swipe to pan
      const newTransform = transform.translate(-event.deltaX, -event.deltaY);
      d3.select(this).call(zoom.transform, newTransform);
    }
  });
  svg.append('defs').html('<marker id="arrow" viewBox="0 -5 10 10" refX="20" refY="0" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,-5L10,0L0,5" fill="#666"/></marker>');
  const g = new dagre.graphlib.Graph({multigraph: true})
    .setGraph({rankdir:'TB', nodesep: 40, ranksep: 80})
    .setDefaultEdgeLabel(()=>{});
  for (const n of graph.nodes||[]) {
    const name = n.name || n.id;
    const action = n.action || '';
    const width = Math.max(100, Math.max(name.length, action.length) * 6 + 20);
    g.setNode(n.id, {label: name + '\n' + action, width, height: 40, name, action});
  }
  for (const e of graph.edges||[]) {
    g.setEdge(e.from, e.to, {edgeId: e.id}, e.id);
  }
  dagre.layout(g);

  // Calculate bounding box for centering
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const id of g.nodes()) {
    const nd = g.node(id);
    minX = Math.min(minX, nd.x - nd.width/2);
    minY = Math.min(minY, nd.y - nd.height/2);
    maxX = Math.max(maxX, nd.x + nd.width/2);
    maxY = Math.max(maxY, nd.y + nd.height/2);
  }

  for (const e of g.edges()) {
    const ed = g.edge(e);
    const edgeId = ed.edgeId;
    const edgeData = edgeDataMap[edgeId];
    container.append('path')
      .attr('class', 'edgePath')
      .attr('d', lineFromPoints(ed.points));
    if(edgeData){
      const mid = ed.points[Math.floor(ed.points.length/2)];
      container.append('text')
        .attr('class', 'edge-label')
        .attr('x', mid.x)
        .attr('y', mid.y)
        .attr('text-anchor', 'middle')
        .text(edgeData.count)
        .on('click', ()=>{
          loadEdgeData(edgeId);
        });
    }
  }
  for (const id of g.nodes()) {
    const nd = g.node(id);
    const nodeG = container.append('g')
      .attr('class', 'node')
      .attr('transform', `translate(${nd.x},${nd.y})`);
    nodeG.append('rect')
      .attr('x', -nd.width/2)
      .attr('y', -nd.height/2)
      .attr('width', nd.width)
      .attr('height', nd.height)
      .attr('class', 'node-rect');
    const text = nodeG.append('text')
      .attr('text-anchor', 'middle')
      .attr('class', 'node-label');
    text.append('tspan')
      .attr('x', 0)
      .attr('dy', '-0.5em')
      .text(nd.name);
    text.append('tspan')
      .attr('x', 0)
      .attr('dy', '1em')
      .attr('class', 'node-label-action')
      .text(nd.action);
  }
  function lineFromPoints(points){
    if(!points || points.length===0) return '';
    return points.map((p,i)=> (i===0? 'M':'L') + p.x + ',' + p.y).join(' ');
  }

  // Center the graph in the viewport
  const graphWidth = maxX - minX;
  const graphHeight = maxY - minY;
  const svgWidth = +svg.attr('width');
  const svgHeight = +svg.attr('height');

  const scale = Math.min(
    svgWidth / (graphWidth + 100),
    svgHeight / (graphHeight + 100),
    1
  );

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const translateX = svgWidth / 2 - centerX * scale;
  const translateY = svgHeight / 2 - centerY * scale;

  svg.call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

const graphs = findGraphs(workflowDoc);
if(graphs.length > 0) {
  graphs.forEach((g,i)=>{
    const o = document.createElement('option');
    o.value=i;
    o.text = g.name||g.id||'graph#'+(i+1);
    graphSel.add(o);
  });
  graphSel.onchange = ()=> layoutAndRender(graphs[+graphSel.value]);
  graphSel.value = graphs.length - 1;
  graphSel.onchange();
}
</script>
