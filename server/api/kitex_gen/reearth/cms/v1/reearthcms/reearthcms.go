// Code generated by Kitex v0.14.1. DO NOT EDIT.

package reearthcms

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
	v1 "github.com/reearth/reearth-flow/api/kitex_gen/reearth/cms/v1"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"CreateProject": kitex.NewMethodInfo(
		createProjectHandler,
		newCreateProjectArgs,
		newCreateProjectResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateProject": kitex.NewMethodInfo(
		updateProjectHandler,
		newUpdateProjectArgs,
		newUpdateProjectResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteProject": kitex.NewMethodInfo(
		deleteProjectHandler,
		newDeleteProjectArgs,
		newDeleteProjectResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CheckAliasAvailability": kitex.NewMethodInfo(
		checkAliasAvailabilityHandler,
		newCheckAliasAvailabilityArgs,
		newCheckAliasAvailabilityResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetProject": kitex.NewMethodInfo(
		getProjectHandler,
		newGetProjectArgs,
		newGetProjectResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListProjects": kitex.NewMethodInfo(
		listProjectsHandler,
		newListProjectsArgs,
		newListProjectsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListModels": kitex.NewMethodInfo(
		listModelsHandler,
		newListModelsArgs,
		newListModelsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListItems": kitex.NewMethodInfo(
		listItemsHandler,
		newListItemsArgs,
		newListItemsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetModelGeoJSONExportURL": kitex.NewMethodInfo(
		getModelGeoJSONExportURLHandler,
		newGetModelGeoJSONExportURLArgs,
		newGetModelGeoJSONExportURLResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	reEarthCMSServiceInfo                = NewServiceInfo()
	reEarthCMSServiceInfoForClient       = NewServiceInfoForClient()
	reEarthCMSServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return reEarthCMSServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return reEarthCMSServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return reEarthCMSServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "ReEarthCMS"
	handlerType := (*v1.ReEarthCMS)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "reearth.cms.v1",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func createProjectHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.CreateProjectRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).CreateProject(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateProjectArgs:
		success, err := handler.(v1.ReEarthCMS).CreateProject(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateProjectResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateProjectArgs() interface{} {
	return &CreateProjectArgs{}
}

func newCreateProjectResult() interface{} {
	return &CreateProjectResult{}
}

type CreateProjectArgs struct {
	Req *v1.CreateProjectRequest
}

func (p *CreateProjectArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateProjectArgs) Unmarshal(in []byte) error {
	msg := new(v1.CreateProjectRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateProjectArgs_Req_DEFAULT *v1.CreateProjectRequest

func (p *CreateProjectArgs) GetReq() *v1.CreateProjectRequest {
	if !p.IsSetReq() {
		return CreateProjectArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateProjectArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateProjectArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateProjectResult struct {
	Success *v1.ProjectResponse
}

var CreateProjectResult_Success_DEFAULT *v1.ProjectResponse

func (p *CreateProjectResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateProjectResult) Unmarshal(in []byte) error {
	msg := new(v1.ProjectResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateProjectResult) GetSuccess() *v1.ProjectResponse {
	if !p.IsSetSuccess() {
		return CreateProjectResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateProjectResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ProjectResponse)
}

func (p *CreateProjectResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateProjectResult) GetResult() interface{} {
	return p.Success
}

func updateProjectHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.UpdateProjectRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).UpdateProject(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateProjectArgs:
		success, err := handler.(v1.ReEarthCMS).UpdateProject(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateProjectResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateProjectArgs() interface{} {
	return &UpdateProjectArgs{}
}

func newUpdateProjectResult() interface{} {
	return &UpdateProjectResult{}
}

type UpdateProjectArgs struct {
	Req *v1.UpdateProjectRequest
}

func (p *UpdateProjectArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateProjectArgs) Unmarshal(in []byte) error {
	msg := new(v1.UpdateProjectRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateProjectArgs_Req_DEFAULT *v1.UpdateProjectRequest

func (p *UpdateProjectArgs) GetReq() *v1.UpdateProjectRequest {
	if !p.IsSetReq() {
		return UpdateProjectArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateProjectArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateProjectArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateProjectResult struct {
	Success *v1.ProjectResponse
}

var UpdateProjectResult_Success_DEFAULT *v1.ProjectResponse

func (p *UpdateProjectResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateProjectResult) Unmarshal(in []byte) error {
	msg := new(v1.ProjectResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateProjectResult) GetSuccess() *v1.ProjectResponse {
	if !p.IsSetSuccess() {
		return UpdateProjectResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateProjectResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ProjectResponse)
}

func (p *UpdateProjectResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateProjectResult) GetResult() interface{} {
	return p.Success
}

func deleteProjectHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.DeleteProjectRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).DeleteProject(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteProjectArgs:
		success, err := handler.(v1.ReEarthCMS).DeleteProject(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteProjectResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteProjectArgs() interface{} {
	return &DeleteProjectArgs{}
}

func newDeleteProjectResult() interface{} {
	return &DeleteProjectResult{}
}

type DeleteProjectArgs struct {
	Req *v1.DeleteProjectRequest
}

func (p *DeleteProjectArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteProjectArgs) Unmarshal(in []byte) error {
	msg := new(v1.DeleteProjectRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteProjectArgs_Req_DEFAULT *v1.DeleteProjectRequest

func (p *DeleteProjectArgs) GetReq() *v1.DeleteProjectRequest {
	if !p.IsSetReq() {
		return DeleteProjectArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteProjectArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteProjectArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteProjectResult struct {
	Success *v1.DeleteProjectResponse
}

var DeleteProjectResult_Success_DEFAULT *v1.DeleteProjectResponse

func (p *DeleteProjectResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteProjectResult) Unmarshal(in []byte) error {
	msg := new(v1.DeleteProjectResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteProjectResult) GetSuccess() *v1.DeleteProjectResponse {
	if !p.IsSetSuccess() {
		return DeleteProjectResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteProjectResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.DeleteProjectResponse)
}

func (p *DeleteProjectResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteProjectResult) GetResult() interface{} {
	return p.Success
}

func checkAliasAvailabilityHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.AliasAvailabilityRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).CheckAliasAvailability(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CheckAliasAvailabilityArgs:
		success, err := handler.(v1.ReEarthCMS).CheckAliasAvailability(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckAliasAvailabilityResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCheckAliasAvailabilityArgs() interface{} {
	return &CheckAliasAvailabilityArgs{}
}

func newCheckAliasAvailabilityResult() interface{} {
	return &CheckAliasAvailabilityResult{}
}

type CheckAliasAvailabilityArgs struct {
	Req *v1.AliasAvailabilityRequest
}

func (p *CheckAliasAvailabilityArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CheckAliasAvailabilityArgs) Unmarshal(in []byte) error {
	msg := new(v1.AliasAvailabilityRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckAliasAvailabilityArgs_Req_DEFAULT *v1.AliasAvailabilityRequest

func (p *CheckAliasAvailabilityArgs) GetReq() *v1.AliasAvailabilityRequest {
	if !p.IsSetReq() {
		return CheckAliasAvailabilityArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckAliasAvailabilityArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CheckAliasAvailabilityArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CheckAliasAvailabilityResult struct {
	Success *v1.AliasAvailabilityResponse
}

var CheckAliasAvailabilityResult_Success_DEFAULT *v1.AliasAvailabilityResponse

func (p *CheckAliasAvailabilityResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CheckAliasAvailabilityResult) Unmarshal(in []byte) error {
	msg := new(v1.AliasAvailabilityResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckAliasAvailabilityResult) GetSuccess() *v1.AliasAvailabilityResponse {
	if !p.IsSetSuccess() {
		return CheckAliasAvailabilityResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckAliasAvailabilityResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.AliasAvailabilityResponse)
}

func (p *CheckAliasAvailabilityResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAliasAvailabilityResult) GetResult() interface{} {
	return p.Success
}

func getProjectHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.ProjectRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).GetProject(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetProjectArgs:
		success, err := handler.(v1.ReEarthCMS).GetProject(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetProjectResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetProjectArgs() interface{} {
	return &GetProjectArgs{}
}

func newGetProjectResult() interface{} {
	return &GetProjectResult{}
}

type GetProjectArgs struct {
	Req *v1.ProjectRequest
}

func (p *GetProjectArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetProjectArgs) Unmarshal(in []byte) error {
	msg := new(v1.ProjectRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetProjectArgs_Req_DEFAULT *v1.ProjectRequest

func (p *GetProjectArgs) GetReq() *v1.ProjectRequest {
	if !p.IsSetReq() {
		return GetProjectArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetProjectArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetProjectArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetProjectResult struct {
	Success *v1.ProjectResponse
}

var GetProjectResult_Success_DEFAULT *v1.ProjectResponse

func (p *GetProjectResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetProjectResult) Unmarshal(in []byte) error {
	msg := new(v1.ProjectResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetProjectResult) GetSuccess() *v1.ProjectResponse {
	if !p.IsSetSuccess() {
		return GetProjectResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetProjectResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ProjectResponse)
}

func (p *GetProjectResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetProjectResult) GetResult() interface{} {
	return p.Success
}

func listProjectsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.ListProjectsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).ListProjects(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListProjectsArgs:
		success, err := handler.(v1.ReEarthCMS).ListProjects(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListProjectsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListProjectsArgs() interface{} {
	return &ListProjectsArgs{}
}

func newListProjectsResult() interface{} {
	return &ListProjectsResult{}
}

type ListProjectsArgs struct {
	Req *v1.ListProjectsRequest
}

func (p *ListProjectsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListProjectsArgs) Unmarshal(in []byte) error {
	msg := new(v1.ListProjectsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListProjectsArgs_Req_DEFAULT *v1.ListProjectsRequest

func (p *ListProjectsArgs) GetReq() *v1.ListProjectsRequest {
	if !p.IsSetReq() {
		return ListProjectsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListProjectsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListProjectsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListProjectsResult struct {
	Success *v1.ListProjectsResponse
}

var ListProjectsResult_Success_DEFAULT *v1.ListProjectsResponse

func (p *ListProjectsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListProjectsResult) Unmarshal(in []byte) error {
	msg := new(v1.ListProjectsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListProjectsResult) GetSuccess() *v1.ListProjectsResponse {
	if !p.IsSetSuccess() {
		return ListProjectsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListProjectsResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ListProjectsResponse)
}

func (p *ListProjectsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListProjectsResult) GetResult() interface{} {
	return p.Success
}

func listModelsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.ListModelsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).ListModels(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListModelsArgs:
		success, err := handler.(v1.ReEarthCMS).ListModels(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListModelsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListModelsArgs() interface{} {
	return &ListModelsArgs{}
}

func newListModelsResult() interface{} {
	return &ListModelsResult{}
}

type ListModelsArgs struct {
	Req *v1.ListModelsRequest
}

func (p *ListModelsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListModelsArgs) Unmarshal(in []byte) error {
	msg := new(v1.ListModelsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListModelsArgs_Req_DEFAULT *v1.ListModelsRequest

func (p *ListModelsArgs) GetReq() *v1.ListModelsRequest {
	if !p.IsSetReq() {
		return ListModelsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListModelsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListModelsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListModelsResult struct {
	Success *v1.ListModelsResponse
}

var ListModelsResult_Success_DEFAULT *v1.ListModelsResponse

func (p *ListModelsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListModelsResult) Unmarshal(in []byte) error {
	msg := new(v1.ListModelsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListModelsResult) GetSuccess() *v1.ListModelsResponse {
	if !p.IsSetSuccess() {
		return ListModelsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListModelsResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ListModelsResponse)
}

func (p *ListModelsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListModelsResult) GetResult() interface{} {
	return p.Success
}

func listItemsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.ListItemsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).ListItems(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListItemsArgs:
		success, err := handler.(v1.ReEarthCMS).ListItems(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListItemsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListItemsArgs() interface{} {
	return &ListItemsArgs{}
}

func newListItemsResult() interface{} {
	return &ListItemsResult{}
}

type ListItemsArgs struct {
	Req *v1.ListItemsRequest
}

func (p *ListItemsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListItemsArgs) Unmarshal(in []byte) error {
	msg := new(v1.ListItemsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListItemsArgs_Req_DEFAULT *v1.ListItemsRequest

func (p *ListItemsArgs) GetReq() *v1.ListItemsRequest {
	if !p.IsSetReq() {
		return ListItemsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListItemsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListItemsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListItemsResult struct {
	Success *v1.ListItemsResponse
}

var ListItemsResult_Success_DEFAULT *v1.ListItemsResponse

func (p *ListItemsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListItemsResult) Unmarshal(in []byte) error {
	msg := new(v1.ListItemsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListItemsResult) GetSuccess() *v1.ListItemsResponse {
	if !p.IsSetSuccess() {
		return ListItemsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListItemsResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ListItemsResponse)
}

func (p *ListItemsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListItemsResult) GetResult() interface{} {
	return p.Success
}

func getModelGeoJSONExportURLHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(v1.ExportRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(v1.ReEarthCMS).GetModelGeoJSONExportURL(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetModelGeoJSONExportURLArgs:
		success, err := handler.(v1.ReEarthCMS).GetModelGeoJSONExportURL(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetModelGeoJSONExportURLResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetModelGeoJSONExportURLArgs() interface{} {
	return &GetModelGeoJSONExportURLArgs{}
}

func newGetModelGeoJSONExportURLResult() interface{} {
	return &GetModelGeoJSONExportURLResult{}
}

type GetModelGeoJSONExportURLArgs struct {
	Req *v1.ExportRequest
}

func (p *GetModelGeoJSONExportURLArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetModelGeoJSONExportURLArgs) Unmarshal(in []byte) error {
	msg := new(v1.ExportRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetModelGeoJSONExportURLArgs_Req_DEFAULT *v1.ExportRequest

func (p *GetModelGeoJSONExportURLArgs) GetReq() *v1.ExportRequest {
	if !p.IsSetReq() {
		return GetModelGeoJSONExportURLArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetModelGeoJSONExportURLArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetModelGeoJSONExportURLArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetModelGeoJSONExportURLResult struct {
	Success *v1.ExportURLResponse
}

var GetModelGeoJSONExportURLResult_Success_DEFAULT *v1.ExportURLResponse

func (p *GetModelGeoJSONExportURLResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetModelGeoJSONExportURLResult) Unmarshal(in []byte) error {
	msg := new(v1.ExportURLResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetModelGeoJSONExportURLResult) GetSuccess() *v1.ExportURLResponse {
	if !p.IsSetSuccess() {
		return GetModelGeoJSONExportURLResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetModelGeoJSONExportURLResult) SetSuccess(x interface{}) {
	p.Success = x.(*v1.ExportURLResponse)
}

func (p *GetModelGeoJSONExportURLResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetModelGeoJSONExportURLResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateProject(ctx context.Context, Req *v1.CreateProjectRequest) (r *v1.ProjectResponse, err error) {
	var _args CreateProjectArgs
	_args.Req = Req
	var _result CreateProjectResult
	if err = p.c.Call(ctx, "CreateProject", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateProject(ctx context.Context, Req *v1.UpdateProjectRequest) (r *v1.ProjectResponse, err error) {
	var _args UpdateProjectArgs
	_args.Req = Req
	var _result UpdateProjectResult
	if err = p.c.Call(ctx, "UpdateProject", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteProject(ctx context.Context, Req *v1.DeleteProjectRequest) (r *v1.DeleteProjectResponse, err error) {
	var _args DeleteProjectArgs
	_args.Req = Req
	var _result DeleteProjectResult
	if err = p.c.Call(ctx, "DeleteProject", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckAliasAvailability(ctx context.Context, Req *v1.AliasAvailabilityRequest) (r *v1.AliasAvailabilityResponse, err error) {
	var _args CheckAliasAvailabilityArgs
	_args.Req = Req
	var _result CheckAliasAvailabilityResult
	if err = p.c.Call(ctx, "CheckAliasAvailability", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetProject(ctx context.Context, Req *v1.ProjectRequest) (r *v1.ProjectResponse, err error) {
	var _args GetProjectArgs
	_args.Req = Req
	var _result GetProjectResult
	if err = p.c.Call(ctx, "GetProject", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListProjects(ctx context.Context, Req *v1.ListProjectsRequest) (r *v1.ListProjectsResponse, err error) {
	var _args ListProjectsArgs
	_args.Req = Req
	var _result ListProjectsResult
	if err = p.c.Call(ctx, "ListProjects", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListModels(ctx context.Context, Req *v1.ListModelsRequest) (r *v1.ListModelsResponse, err error) {
	var _args ListModelsArgs
	_args.Req = Req
	var _result ListModelsResult
	if err = p.c.Call(ctx, "ListModels", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListItems(ctx context.Context, Req *v1.ListItemsRequest) (r *v1.ListItemsResponse, err error) {
	var _args ListItemsArgs
	_args.Req = Req
	var _result ListItemsResult
	if err = p.c.Call(ctx, "ListItems", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetModelGeoJSONExportURL(ctx context.Context, Req *v1.ExportRequest) (r *v1.ExportURLResponse, err error) {
	var _args GetModelGeoJSONExportURLArgs
	_args.Req = Req
	var _result GetModelGeoJSONExportURLResult
	if err = p.c.Call(ctx, "GetModelGeoJSONExportURL", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
