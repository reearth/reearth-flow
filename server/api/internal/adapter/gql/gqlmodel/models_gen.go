// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"golang.org/x/text/language"
)

type Node interface {
	IsNode()
	GetID() ID
}

type APIDriverInput struct {
	Token string `json:"token"`
}

type AddMemberToWorkspaceInput struct {
	WorkspaceID ID   `json:"workspaceId"`
	UserID      ID   `json:"userId"`
	Role        Role `json:"role"`
}

type AddMemberToWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type Asset struct {
	ContentType string     `json:"contentType"`
	CreatedAt   time.Time  `json:"createdAt"`
	ID          ID         `json:"id"`
	Name        string     `json:"name"`
	Size        int64      `json:"size"`
	URL         string     `json:"url"`
	WorkspaceID ID         `json:"workspaceId"`
	Workspace   *Workspace `json:"Workspace,omitempty"`
}

func (Asset) IsNode()        {}
func (this Asset) GetID() ID { return this.ID }

type AssetConnection struct {
	Nodes      []*Asset  `json:"nodes"`
	PageInfo   *PageInfo `json:"pageInfo"`
	TotalCount int       `json:"totalCount"`
}

type CancelJobInput struct {
	JobID ID `json:"jobId"`
}

type CancelJobPayload struct {
	Job *Job `json:"job,omitempty"`
}

type CreateAssetInput struct {
	WorkspaceID ID             `json:"workspaceId"`
	File        graphql.Upload `json:"file"`
}

type CreateAssetPayload struct {
	Asset *Asset `json:"asset"`
}

type CreateDeploymentInput struct {
	WorkspaceID ID             `json:"workspaceId"`
	File        graphql.Upload `json:"file"`
	ProjectID   *ID            `json:"projectId,omitempty"`
	Description string         `json:"description"`
}

type CreateProjectInput struct {
	WorkspaceID ID      `json:"workspaceId"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Archived    *bool   `json:"archived,omitempty"`
}

type CreateTriggerInput struct {
	WorkspaceID     ID               `json:"workspaceId"`
	DeploymentID    ID               `json:"deploymentId"`
	Description     string           `json:"description"`
	TimeDriverInput *TimeDriverInput `json:"timeDriverInput,omitempty"`
	APIDriverInput  *APIDriverInput  `json:"apiDriverInput,omitempty"`
}

type CreateWorkspaceInput struct {
	Name string `json:"name"`
}

type CreateWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type DeclareParameterInput struct {
	Name     string        `json:"name"`
	Type     ParameterType `json:"type"`
	Required bool          `json:"required"`
	Value    interface{}   `json:"value,omitempty"`
	Index    *int          `json:"index,omitempty"`
}

type DeleteDeploymentInput struct {
	DeploymentID ID `json:"deploymentId"`
}

type DeleteDeploymentPayload struct {
	DeploymentID ID `json:"deploymentId"`
}

type DeleteMeInput struct {
	UserID ID `json:"userId"`
}

type DeleteMePayload struct {
	UserID ID `json:"userId"`
}

type DeleteProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type DeleteProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type DeleteWorkspaceInput struct {
	WorkspaceID ID `json:"workspaceId"`
}

type DeleteWorkspacePayload struct {
	WorkspaceID ID `json:"workspaceId"`
}

type Deployment struct {
	CreatedAt   time.Time  `json:"createdAt"`
	Description string     `json:"description"`
	HeadID      *ID        `json:"headId,omitempty"`
	IsHead      bool       `json:"isHead"`
	ID          ID         `json:"id"`
	Project     *Project   `json:"project,omitempty"`
	ProjectID   *ID        `json:"projectId,omitempty"`
	UpdatedAt   time.Time  `json:"updatedAt"`
	Version     string     `json:"version"`
	WorkflowURL string     `json:"workflowUrl"`
	Workspace   *Workspace `json:"workspace,omitempty"`
	WorkspaceID ID         `json:"workspaceId"`
}

func (Deployment) IsNode()        {}
func (this Deployment) GetID() ID { return this.ID }

type DeploymentConnection struct {
	Nodes      []*Deployment `json:"nodes"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

type DeploymentPayload struct {
	Deployment *Deployment `json:"deployment"`
}

type EdgeExecution struct {
	ID                  ID         `json:"id"`
	EdgeID              string     `json:"edgeId"`
	JobID               ID         `json:"jobId"`
	Status              EdgeStatus `json:"status"`
	CreatedAt           *time.Time `json:"createdAt,omitempty"`
	StartedAt           *time.Time `json:"startedAt,omitempty"`
	CompletedAt         *time.Time `json:"completedAt,omitempty"`
	FeatureID           *ID        `json:"featureId,omitempty"`
	IntermediateDataURL *string    `json:"intermediateDataUrl,omitempty"`
}

func (EdgeExecution) IsNode()        {}
func (this EdgeExecution) GetID() ID { return this.ID }

type ExecuteDeploymentInput struct {
	DeploymentID ID `json:"deploymentId"`
}

type GetByVersionInput struct {
	WorkspaceID ID     `json:"workspaceId"`
	ProjectID   *ID    `json:"projectId,omitempty"`
	Version     string `json:"version"`
}

type GetHeadInput struct {
	WorkspaceID ID  `json:"workspaceId"`
	ProjectID   *ID `json:"projectId,omitempty"`
}

type Job struct {
	CompletedAt   *time.Time  `json:"completedAt,omitempty"`
	Deployment    *Deployment `json:"deployment,omitempty"`
	DeploymentID  ID          `json:"deploymentId"`
	Debug         *bool       `json:"debug,omitempty"`
	ID            ID          `json:"id"`
	LogsURL       *string     `json:"logsURL,omitempty"`
	WorkerLogsURL *string     `json:"workerLogsURL,omitempty"`
	OutputURLs    []string    `json:"outputURLs,omitempty"`
	StartedAt     time.Time   `json:"startedAt"`
	Status        JobStatus   `json:"status"`
	Workspace     *Workspace  `json:"workspace,omitempty"`
	WorkspaceID   ID          `json:"workspaceId"`
	Logs          []*Log      `json:"logs,omitempty"`
}

func (Job) IsNode()        {}
func (this Job) GetID() ID { return this.ID }

type JobConnection struct {
	Nodes      []*Job    `json:"nodes"`
	PageInfo   *PageInfo `json:"pageInfo"`
	TotalCount int       `json:"totalCount"`
}

type JobPayload struct {
	Job *Job `json:"job"`
}

type Log struct {
	JobID     ID        `json:"jobId"`
	NodeID    *ID       `json:"nodeId,omitempty"`
	Timestamp time.Time `json:"timestamp"`
	LogLevel  LogLevel  `json:"logLevel"`
	Message   string    `json:"message"`
}

type Me struct {
	Auths         []string     `json:"auths"`
	Email         string       `json:"email"`
	ID            ID           `json:"id"`
	Lang          language.Tag `json:"lang"`
	MyWorkspace   *Workspace   `json:"myWorkspace,omitempty"`
	MyWorkspaceID ID           `json:"myWorkspaceId"`
	Name          string       `json:"name"`
	Workspaces    []*Workspace `json:"workspaces"`
}

type Mutation struct {
}

type PageBasedPagination struct {
	Page     int             `json:"page"`
	PageSize int             `json:"pageSize"`
	OrderBy  *string         `json:"orderBy,omitempty"`
	OrderDir *OrderDirection `json:"orderDir,omitempty"`
}

type PageInfo struct {
	TotalCount  int  `json:"totalCount"`
	CurrentPage *int `json:"currentPage,omitempty"`
	TotalPages  *int `json:"totalPages,omitempty"`
}

type Pagination struct {
	Page     *int            `json:"page,omitempty"`
	PageSize *int            `json:"pageSize,omitempty"`
	OrderBy  *string         `json:"orderBy,omitempty"`
	OrderDir *OrderDirection `json:"orderDir,omitempty"`
}

type Parameter struct {
	CreatedAt time.Time     `json:"createdAt"`
	ID        ID            `json:"id"`
	Index     int           `json:"index"`
	Name      string        `json:"name"`
	ProjectID ID            `json:"projectId"`
	Required  bool          `json:"required"`
	Type      ParameterType `json:"type"`
	UpdatedAt time.Time     `json:"updatedAt"`
	Value     interface{}   `json:"value"`
}

type Project struct {
	BasicAuthPassword string       `json:"basicAuthPassword"`
	BasicAuthUsername string       `json:"basicAuthUsername"`
	CreatedAt         time.Time    `json:"createdAt"`
	Description       string       `json:"description"`
	Deployment        *Deployment  `json:"deployment,omitempty"`
	ID                ID           `json:"id"`
	IsArchived        bool         `json:"isArchived"`
	IsBasicAuthActive bool         `json:"isBasicAuthActive"`
	Name              string       `json:"name"`
	Parameters        []*Parameter `json:"parameters"`
	UpdatedAt         time.Time    `json:"updatedAt"`
	SharedToken       *string      `json:"sharedToken,omitempty"`
	Version           int          `json:"version"`
	Workspace         *Workspace   `json:"workspace,omitempty"`
	WorkspaceID       ID           `json:"workspaceId"`
}

func (Project) IsNode()        {}
func (this Project) GetID() ID { return this.ID }

type ProjectConnection struct {
	Nodes      []*Project `json:"nodes"`
	PageInfo   *PageInfo  `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

type ProjectDocument struct {
	ID        ID        `json:"id"`
	Timestamp time.Time `json:"timestamp"`
	Updates   []int     `json:"updates"`
	Version   int       `json:"version"`
}

func (ProjectDocument) IsNode()        {}
func (this ProjectDocument) GetID() ID { return this.ID }

type ProjectPayload struct {
	Project *Project `json:"project"`
}

type ProjectSharingInfoPayload struct {
	ProjectID    ID      `json:"projectId"`
	SharingToken *string `json:"sharingToken,omitempty"`
}

type ProjectSnapshot struct {
	Timestamp time.Time `json:"timestamp"`
	Updates   []int     `json:"updates"`
	Version   int       `json:"version"`
}

type Query struct {
}

type RemoveAssetInput struct {
	AssetID ID `json:"assetId"`
}

type RemoveAssetPayload struct {
	AssetID ID `json:"assetId"`
}

type RemoveMemberFromWorkspaceInput struct {
	WorkspaceID ID `json:"workspaceId"`
	UserID      ID `json:"userId"`
}

type RemoveMemberFromWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type RemoveMyAuthInput struct {
	Auth string `json:"auth"`
}

type RemoveParameterInput struct {
	ParamID ID `json:"paramId"`
}

type RunProjectInput struct {
	ProjectID   ID             `json:"projectId"`
	WorkspaceID ID             `json:"workspaceId"`
	File        graphql.Upload `json:"file"`
}

type RunProjectPayload struct {
	Job *Job `json:"job"`
}

type ShareProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type ShareProjectPayload struct {
	ProjectID  ID     `json:"projectId"`
	SharingURL string `json:"sharingUrl"`
}

type SharedProjectPayload struct {
	Project *Project `json:"project"`
}

type SignupInput struct {
	UserID      *ID           `json:"userId,omitempty"`
	Lang        *language.Tag `json:"lang,omitempty"`
	WorkspaceID *ID           `json:"workspaceId,omitempty"`
	Secret      *string       `json:"secret,omitempty"`
}

type SignupPayload struct {
	User      *User      `json:"user"`
	Workspace *Workspace `json:"workspace"`
}

type Subscription struct {
}

type TimeDriverInput struct {
	Interval TimeInterval `json:"interval"`
}

type Trigger struct {
	ID            ID              `json:"id"`
	CreatedAt     time.Time       `json:"createdAt"`
	UpdatedAt     time.Time       `json:"updatedAt"`
	LastTriggered *time.Time      `json:"lastTriggered,omitempty"`
	WorkspaceID   ID              `json:"workspaceId"`
	Workspace     *Workspace      `json:"workspace,omitempty"`
	Deployment    *Deployment     `json:"deployment"`
	DeploymentID  ID              `json:"deploymentId"`
	EventSource   EventSourceType `json:"eventSource"`
	Description   string          `json:"description"`
	AuthToken     *string         `json:"authToken,omitempty"`
	TimeInterval  *TimeInterval   `json:"timeInterval,omitempty"`
}

func (Trigger) IsNode()        {}
func (this Trigger) GetID() ID { return this.ID }

type TriggerConnection struct {
	Nodes      []*Trigger `json:"nodes"`
	PageInfo   *PageInfo  `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

type UnshareProjectInput struct {
	ProjectID ID `json:"projectId"`
}

type UnshareProjectPayload struct {
	ProjectID ID `json:"projectId"`
}

type UpdateDeploymentInput struct {
	DeploymentID ID              `json:"deploymentId"`
	File         *graphql.Upload `json:"file,omitempty"`
	Description  *string         `json:"description,omitempty"`
}

type UpdateMeInput struct {
	Name                 *string       `json:"name,omitempty"`
	Email                *string       `json:"email,omitempty"`
	Password             *string       `json:"password,omitempty"`
	PasswordConfirmation *string       `json:"passwordConfirmation,omitempty"`
	Lang                 *language.Tag `json:"lang,omitempty"`
}

type UpdateMePayload struct {
	Me *Me `json:"me"`
}

type UpdateMemberOfWorkspaceInput struct {
	WorkspaceID ID   `json:"workspaceId"`
	UserID      ID   `json:"userId"`
	Role        Role `json:"role"`
}

type UpdateMemberOfWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type UpdateParameterOrderInput struct {
	ParamID  ID  `json:"paramId"`
	NewIndex int `json:"newIndex"`
}

type UpdateParameterValueInput struct {
	Value interface{} `json:"value"`
}

type UpdateProjectInput struct {
	ProjectID         ID      `json:"projectId"`
	Name              *string `json:"name,omitempty"`
	Description       *string `json:"description,omitempty"`
	Archived          *bool   `json:"archived,omitempty"`
	IsBasicAuthActive *bool   `json:"isBasicAuthActive,omitempty"`
	BasicAuthUsername *string `json:"basicAuthUsername,omitempty"`
	BasicAuthPassword *string `json:"basicAuthPassword,omitempty"`
}

type UpdateTriggerInput struct {
	TriggerID       ID               `json:"triggerId"`
	Description     *string          `json:"description,omitempty"`
	DeploymentID    *ID              `json:"deploymentId,omitempty"`
	TimeDriverInput *TimeDriverInput `json:"timeDriverInput,omitempty"`
	APIDriverInput  *APIDriverInput  `json:"apiDriverInput,omitempty"`
}

type UpdateWorkspaceInput struct {
	WorkspaceID ID     `json:"workspaceId"`
	Name        string `json:"name"`
}

type UpdateWorkspacePayload struct {
	Workspace *Workspace `json:"workspace"`
}

type User struct {
	Email string  `json:"email"`
	Host  *string `json:"host,omitempty"`
	ID    ID      `json:"id"`
	Name  string  `json:"name"`
}

func (User) IsNode()        {}
func (this User) GetID() ID { return this.ID }

type Workspace struct {
	Assets   *AssetConnection   `json:"assets"`
	ID       ID                 `json:"id"`
	Members  []*WorkspaceMember `json:"members"`
	Name     string             `json:"name"`
	Personal bool               `json:"personal"`
	Projects *ProjectConnection `json:"projects"`
}

func (Workspace) IsNode()        {}
func (this Workspace) GetID() ID { return this.ID }

type WorkspaceMember struct {
	Role   Role  `json:"role"`
	User   *User `json:"user,omitempty"`
	UserID ID    `json:"userId"`
}

type AssetSortType string

const (
	AssetSortTypeDate AssetSortType = "DATE"
	AssetSortTypeSize AssetSortType = "SIZE"
	AssetSortTypeName AssetSortType = "NAME"
)

var AllAssetSortType = []AssetSortType{
	AssetSortTypeDate,
	AssetSortTypeSize,
	AssetSortTypeName,
}

func (e AssetSortType) IsValid() bool {
	switch e {
	case AssetSortTypeDate, AssetSortTypeSize, AssetSortTypeName:
		return true
	}
	return false
}

func (e AssetSortType) String() string {
	return string(e)
}

func (e *AssetSortType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetSortType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetSortType", str)
	}
	return nil
}

func (e AssetSortType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EdgeStatus string

const (
	EdgeStatusInProgress EdgeStatus = "IN_PROGRESS"
	EdgeStatusCompleted  EdgeStatus = "COMPLETED"
	EdgeStatusFailed     EdgeStatus = "FAILED"
)

var AllEdgeStatus = []EdgeStatus{
	EdgeStatusInProgress,
	EdgeStatusCompleted,
	EdgeStatusFailed,
}

func (e EdgeStatus) IsValid() bool {
	switch e {
	case EdgeStatusInProgress, EdgeStatusCompleted, EdgeStatusFailed:
		return true
	}
	return false
}

func (e EdgeStatus) String() string {
	return string(e)
}

func (e *EdgeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EdgeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EdgeStatus", str)
	}
	return nil
}

func (e EdgeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventSourceType string

const (
	EventSourceTypeTimeDriven EventSourceType = "TIME_DRIVEN"
	EventSourceTypeAPIDriven  EventSourceType = "API_DRIVEN"
)

var AllEventSourceType = []EventSourceType{
	EventSourceTypeTimeDriven,
	EventSourceTypeAPIDriven,
}

func (e EventSourceType) IsValid() bool {
	switch e {
	case EventSourceTypeTimeDriven, EventSourceTypeAPIDriven:
		return true
	}
	return false
}

func (e EventSourceType) String() string {
	return string(e)
}

func (e *EventSourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventSourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventSourceType", str)
	}
	return nil
}

func (e EventSourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobStatus string

const (
	JobStatusCancelled JobStatus = "CANCELLED"
	JobStatusCompleted JobStatus = "COMPLETED"
	JobStatusFailed    JobStatus = "FAILED"
	JobStatusPending   JobStatus = "PENDING"
	JobStatusRunning   JobStatus = "RUNNING"
)

var AllJobStatus = []JobStatus{
	JobStatusCancelled,
	JobStatusCompleted,
	JobStatusFailed,
	JobStatusPending,
	JobStatusRunning,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusCancelled, JobStatusCompleted, JobStatusFailed, JobStatusPending, JobStatusRunning:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogLevel string

const (
	LogLevelError LogLevel = "ERROR"
	LogLevelWarn  LogLevel = "WARN"
	LogLevelInfo  LogLevel = "INFO"
	LogLevelDebug LogLevel = "DEBUG"
	LogLevelTrace LogLevel = "TRACE"
)

var AllLogLevel = []LogLevel{
	LogLevelError,
	LogLevelWarn,
	LogLevelInfo,
	LogLevelDebug,
	LogLevelTrace,
}

func (e LogLevel) IsValid() bool {
	switch e {
	case LogLevelError, LogLevelWarn, LogLevelInfo, LogLevelDebug, LogLevelTrace:
		return true
	}
	return false
}

func (e LogLevel) String() string {
	return string(e)
}

func (e *LogLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogLevel", str)
	}
	return nil
}

func (e LogLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeAsset     NodeType = "ASSET"
	NodeTypeProject   NodeType = "PROJECT"
	NodeTypeUser      NodeType = "USER"
	NodeTypeWorkspace NodeType = "WORKSPACE"
)

var AllNodeType = []NodeType{
	NodeTypeAsset,
	NodeTypeProject,
	NodeTypeUser,
	NodeTypeWorkspace,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeAsset, NodeTypeProject, NodeTypeUser, NodeTypeWorkspace:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ParameterType string

const (
	ParameterTypeChoice             ParameterType = "CHOICE"
	ParameterTypeColor              ParameterType = "COLOR"
	ParameterTypeDatetime           ParameterType = "DATETIME"
	ParameterTypeFileFolder         ParameterType = "FILE_FOLDER"
	ParameterTypeMessage            ParameterType = "MESSAGE"
	ParameterTypeNumber             ParameterType = "NUMBER"
	ParameterTypePassword           ParameterType = "PASSWORD"
	ParameterTypeText               ParameterType = "TEXT"
	ParameterTypeYesNo              ParameterType = "YES_NO"
	ParameterTypeAttributeName      ParameterType = "ATTRIBUTE_NAME"
	ParameterTypeCoordinateSystem   ParameterType = "COORDINATE_SYSTEM"
	ParameterTypeDatabaseConnection ParameterType = "DATABASE_CONNECTION"
	ParameterTypeGeometry           ParameterType = "GEOMETRY"
	ParameterTypeReprojectionFile   ParameterType = "REPROJECTION_FILE"
	ParameterTypeWebConnection      ParameterType = "WEB_CONNECTION"
)

var AllParameterType = []ParameterType{
	ParameterTypeChoice,
	ParameterTypeColor,
	ParameterTypeDatetime,
	ParameterTypeFileFolder,
	ParameterTypeMessage,
	ParameterTypeNumber,
	ParameterTypePassword,
	ParameterTypeText,
	ParameterTypeYesNo,
	ParameterTypeAttributeName,
	ParameterTypeCoordinateSystem,
	ParameterTypeDatabaseConnection,
	ParameterTypeGeometry,
	ParameterTypeReprojectionFile,
	ParameterTypeWebConnection,
}

func (e ParameterType) IsValid() bool {
	switch e {
	case ParameterTypeChoice, ParameterTypeColor, ParameterTypeDatetime, ParameterTypeFileFolder, ParameterTypeMessage, ParameterTypeNumber, ParameterTypePassword, ParameterTypeText, ParameterTypeYesNo, ParameterTypeAttributeName, ParameterTypeCoordinateSystem, ParameterTypeDatabaseConnection, ParameterTypeGeometry, ParameterTypeReprojectionFile, ParameterTypeWebConnection:
		return true
	}
	return false
}

func (e ParameterType) String() string {
	return string(e)
}

func (e *ParameterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ParameterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ParameterType", str)
	}
	return nil
}

func (e ParameterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleMaintainer Role = "MAINTAINER"
	RoleOwner      Role = "OWNER"
	RoleReader     Role = "READER"
	RoleWriter     Role = "WRITER"
)

var AllRole = []Role{
	RoleMaintainer,
	RoleOwner,
	RoleReader,
	RoleWriter,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleMaintainer, RoleOwner, RoleReader, RoleWriter:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimeInterval string

const (
	TimeIntervalEveryDay   TimeInterval = "EVERY_DAY"
	TimeIntervalEveryHour  TimeInterval = "EVERY_HOUR"
	TimeIntervalEveryMonth TimeInterval = "EVERY_MONTH"
	TimeIntervalEveryWeek  TimeInterval = "EVERY_WEEK"
)

var AllTimeInterval = []TimeInterval{
	TimeIntervalEveryDay,
	TimeIntervalEveryHour,
	TimeIntervalEveryMonth,
	TimeIntervalEveryWeek,
}

func (e TimeInterval) IsValid() bool {
	switch e {
	case TimeIntervalEveryDay, TimeIntervalEveryHour, TimeIntervalEveryMonth, TimeIntervalEveryWeek:
		return true
	}
	return false
}

func (e TimeInterval) String() string {
	return string(e)
}

func (e *TimeInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeInterval", str)
	}
	return nil
}

func (e TimeInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
